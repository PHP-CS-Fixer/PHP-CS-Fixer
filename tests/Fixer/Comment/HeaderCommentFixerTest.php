<?php

declare(strict_types=1);

/*
 * This file is part of PHP CS Fixer.
 *
 * (c) Fabien Potencier <fabien@symfony.com>
 *     Dariusz Rumi≈Ñski <dariusz.ruminski@gmail.com>
 *
 * This source file is subject to the MIT license that is bundled
 * with this source code in the file LICENSE.
 */

namespace PhpCsFixer\Tests\Fixer\Comment;

use PhpCsFixer\ConfigurationException\InvalidFixerConfigurationException;
use PhpCsFixer\ConfigurationException\RequiredFixerConfigurationException;
use PhpCsFixer\Fixer\Comment\HeaderCommentFixer;
use PhpCsFixer\Tests\Test\AbstractFixerTestCase;
use PhpCsFixer\WhitespacesFixerConfig;

/**
 * @internal
 *
 * @covers \PhpCsFixer\Fixer\Comment\HeaderCommentFixer
 *
 * @extends AbstractFixerTestCase<\PhpCsFixer\Fixer\Comment\HeaderCommentFixer>
 *
 * @phpstan-import-type _AutogeneratedInputConfiguration from \PhpCsFixer\Fixer\Comment\HeaderCommentFixer
 *
 * @no-named-arguments Parameter names are not covered by the backward compatibility promise.
 */
final class HeaderCommentFixerTest extends AbstractFixerTestCase
{
    /**
     * @param _AutogeneratedInputConfiguration $configuration
     *
     * @dataProvider provideFixCases
     */
    public function testFix(
        string $expected,
        ?string $input,
        array $configuration,
        ?WhitespacesFixerConfig $whitespaceConfig = null
    ): void {
        if (null !== $whitespaceConfig) {
            $this->fixer->setWhitespacesConfig($whitespaceConfig);
        }
        $this->fixer->configure($configuration);
        $this->doTest($expected, $input);
    }

    /**
     * @return iterable<array{string, null|string, _AutogeneratedInputConfiguration, 3?: WhitespacesFixerConfig}>
     */
    public static function provideFixCases(): iterable
    {
        yield [
            '<?php

$a;',
            '<?php

/**
 * new
 */
$a;',
            ['header' => ''],
        ];

        yield [
            '<?php
declare(strict_types=1);

/*
 * tmp
 */

namespace A\B;

echo 1;',
            '<?php
declare(strict_types=1);namespace A\B;

echo 1;',
            [
                'header' => 'tmp',
                'location' => 'after_declare_strict',
            ],
        ];

        yield [
            '<?php
declare(strict_types=1);
/**
 * tmp
 */

namespace A\B;

echo 1;',
            '<?php
declare(strict_types=1);

namespace A\B;

echo 1;',
            [
                'header' => 'tmp',
                'location' => 'after_declare_strict',
                'separate' => 'bottom',
                'comment_type' => HeaderCommentFixer::HEADER_PHPDOC,
            ],
        ];

        yield [
            '<?php

/*
 * tmp
 */

declare(strict_types=1);

namespace A\B;

echo 1;',
            '<?php
declare(strict_types=1);

namespace A\B;

echo 1;',
            [
                'header' => 'tmp',
                'location' => 'after_open',
            ],
        ];

        yield [
            '<?php

/*
 * new
 */
                ',
            '<?php
                    /** test */
                ',
            [
                'header' => 'new',
                'comment_type' => HeaderCommentFixer::HEADER_COMMENT,
            ],
        ];

        yield [
            '<?php

/**
 * new
 */
                ',
            '<?php
                    /* test */
                ',
            [
                'header' => 'new',
                'comment_type' => HeaderCommentFixer::HEADER_PHPDOC,
            ],
        ];

        yield [
            '<?php

/**
 * def
 */
',
            '<?php
',
            [
                'header' => 'def',
                'comment_type' => HeaderCommentFixer::HEADER_PHPDOC,
            ],
        ];

        yield [
            '<?php

/*
 * xyz
 */

    $b;',
            '<?php
    $b;',
            ['header' => 'xyz'],
        ];

        yield [
            '<?php
/*
 * xyz123
 */
    $a;',
            '<?php
    $a;',
            [
                'header' => 'xyz123',
                'separate' => 'none',
            ],
        ];

        yield [
            '<?php

/**
 * abc
 */

$c;',
            '<?php
$c;',
            [
                'header' => 'abc',
                'comment_type' => HeaderCommentFixer::HEADER_PHPDOC,
            ],
        ];

        yield [
            '<?php

/*
 * ghi
 */

$d;',
            '<?php
$d;',
            [
                'header' => 'ghi',
                'separate' => 'both',
            ],
        ];

        yield [
            '<?php

/*
 * ghi
 */
$d;',
            '<?php
$d;',
            [
                'header' => 'ghi',
                'separate' => 'top',
            ],
        ];

        yield [
            '<?php

/*
 * tmp
 */

declare(ticks=1);

echo 1;',
            '<?php
declare(ticks=1);

echo 1;',
            [
                'header' => 'tmp',
                'location' => 'after_declare_strict',
            ],
        ];

        yield [
            '<?php

/*
 * Foo
 */

echo \'bar\';',
            '<?php echo \'bar\';',
            ['header' => 'Foo'],
        ];

        yield [
            '<?php

/*
 * x
 */

echo \'a\';',
            '<?php

/*
 * y
 * z
 */

echo \'a\';',
            ['header' => 'x'],
        ];

        yield [
            '<?php

/*
 * a
 * a
 */

echo \'x\';',
            '<?php


/*
 * b
 * c
 */


echo \'x\';',
            ['header' => "a\na"],
        ];

        yield [
            '<?php
/**
 * foo
 */

declare(strict_types=1);

namespace A;

echo 1;',
            '<?php

declare(strict_types=1);
/**
 * foo
 */

namespace A;

echo 1;',
            [
                'header' => 'foo',
                'location' => 'after_open',
                'separate' => 'bottom',
                'comment_type' => HeaderCommentFixer::HEADER_PHPDOC,
            ],
        ];

        yield [
            '<?php
/**
 * foo
 */

declare(strict_types=1);
/**
 * bar
 */

namespace A;

echo 1;',
            '<?php

declare(strict_types=1);
/**
 * bar
 */

namespace A;

echo 1;',
            [
                'header' => 'foo',
                'location' => 'after_open',
                'separate' => 'bottom',
                'comment_type' => HeaderCommentFixer::HEADER_PHPDOC,
            ],
        ];

        yield [
            '<?php

declare(strict_types=1);
/*
 * Foo
 */
namespace SebastianBergmann\Foo;

class Bar
{
}',
            '<?php
/*
 * Foo
 */

declare(strict_types=1);

namespace SebastianBergmann\Foo;

class Bar
{
}',
            [
                'header' => 'Foo',
                'separate' => 'none',
            ],
        ];

        yield [
            '<?php

/*
 * tmp
 */

/**
 * Foo class doc.
 */
class Foo {}',
            '<?php

/**
 * Foo class doc.
 */
class Foo {}',
            ['header' => 'tmp'],
        ];

        yield [
            '<?php

/*
 * tmp
 */

class Foo {}',
            '<?php

/*
 * Foo class doc.
 */
class Foo {}',
            ['header' => 'tmp'],
        ];

        yield [
            '<?php

/**
 * tmp1
 */

/**
 * Foo class doc.
 */
class Foo {}',
            '<?php

/**
 * Foo class doc.
 */
class Foo {}',
            [
                'header' => 'tmp1',
                'comment_type' => HeaderCommentFixer::HEADER_PHPDOC,
            ],
        ];

        yield [
            '<?php

/**
 * tmp2
 */

class Foo {}',
            '<?php

/**
 * tmp2
 */
class Foo {}',
            [
                'header' => 'tmp2',
                'comment_type' => HeaderCommentFixer::HEADER_PHPDOC,
            ],
        ];

        yield [
            '<?php

/*
 * tmp3
 */
class Foo {}',
            '<?php
/**
 * Foo class doc.
 */
class Foo {}',
            [
                'header' => 'tmp3',
                'separate' => 'top',
            ],
        ];

        yield [
            '<?php

/*
 * bar
 */

declare(strict_types=1);

// foo
foo();',
            '<?php

/*
 * foo
 */

declare(strict_types=1);

// foo
foo();',
            [
                'header' => 'bar',
                'location' => 'after_open',
            ],
        ];

        yield [
            '<?php

/*
 * bar
 */

declare(strict_types=1);

/* foo */
foo();',
            '<?php

/*
 * foo
 */

declare(strict_types=1);

/* foo */
foo();',
            [
                'header' => 'bar',
                'location' => 'after_open',
            ],
        ];

        yield [
            '<?php

/*
 * tmp4
 */

declare(strict_types=1) ?>',
            '<?php
declare(strict_types=1) ?>',
            [
                'header' => 'tmp4',
                'location' => 'after_declare_strict',
            ],
        ];

        yield [
            '#!/usr/bin/env php
<?php
declare(strict_types=1);

/*
 * tmp5
 */

namespace A\B;

echo 1;',
            '#!/usr/bin/env php
<?php
declare(strict_types=1);namespace A\B;

echo 1;',
            [
                'header' => 'tmp5',
                'location' => 'after_declare_strict',
            ],
        ];

        yield [
            'Short mixed file A
Hello<?php echo "World!"; ?>',
            null,
            [
                'header' => 'tmp',
                'location' => 'after_open',
            ],
        ];

        yield [
            'Short mixed file B
<?php echo "Hello"; ?>World!',
            null,
            [
                'header' => 'tmp',
                'location' => 'after_open',
            ],
        ];

        yield [
            'File with anything at the beginning and with multiple opening tags are not supported
<?php
echo 1;
?>Hello World!<?php
script_continues_here();',
            null,
            [
                'header' => 'tmp',
                'location' => 'after_open',
            ],
        ];

        $fileHeaderParts = [
            <<<'EOF'
                This file is part of the xxx.

                (c) Foo Bar <foo@bar.com>
                EOF,
            <<<'EOF'
                For the full copyright and license information, please view the LICENSE
                file that was distributed with this source code.
                EOF,
        ];
        $fileHeaderComment = implode('', $fileHeaderParts);
        $fileHeaderCommentValidator = implode('', [
            '/',
            preg_quote($fileHeaderParts[0], '/'),
            '(?P<EXTRA>.*)??',
            preg_quote($fileHeaderParts[1], '/'),
            '/s',
        ]);

        yield 'using validator, but existing comment in wrong place - adding new one' => [
            '<?php

/*
 * This file is part of the xxx.
 *
 * (c) Foo Bar <foo@bar.com>
 *
 * This
 * is
 * sub
 * note.
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

declare(strict_types=1);

namespace A;

echo 1;',
            '<?php

declare(strict_types=1);
/*
 * This file is part of the xxx.
 *
 * (c) Foo Bar <foo@bar.com>
 *
 * This
 * is
 * sub
 * note.
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace A;

echo 1;',
            [
                'header' => $fileHeaderComment,
                'validator' => $fileHeaderCommentValidator,
                'location' => 'after_open',
            ],
        ];

        yield 'using validator, existing comment matches' => [
            '<?php

/*
 * This file is part of the xxx.
 *
 * (c) Foo Bar <foo@bar.com>
 *
 * This
 * is
 * sub
 * note.
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

declare(strict_types=1);

namespace A;

echo 1;',
            null,
            [
                'header' => $fileHeaderComment,
                'validator' => $fileHeaderCommentValidator,
                'location' => 'after_open',
            ],
        ];

        yield 'using validator, existing comment matches but misplaced' => [
            '<?php

/**
 * This file is part of the xxx.
 *
 * (c) Foo Bar <foo@bar.com>
 *
 * This
 * is
 * sub
 * note.
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

class Foo {}',
            '<?php

/**
 * This file is part of the xxx.
 *
 * (c) Foo Bar <foo@bar.com>
 *
 * This
 * is
 * sub
 * note.
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
class Foo {}',
            [
                'header' => $fileHeaderComment,
                'validator' => $fileHeaderCommentValidator,
                'comment_type' => HeaderCommentFixer::HEADER_PHPDOC,
            ],
        ];

        yield 'default configuration' => [
            '<?php

/*
 * a
 */

echo 1;',
            '<?php
echo 1;',
            ['header' => 'a'],
        ];

        yield [
            '<?php

/*
 * a
 */

echo 1;',
            '<?php
echo 1;',
            [
                'header' => 'a',
                'comment_type' => HeaderCommentFixer::HEADER_COMMENT,
            ],
        ];

        yield [
            '<?php

/**
 * a
 */

echo 1;',
            '<?php
echo 1;',
            [
                'header' => 'a',
                'comment_type' => HeaderCommentFixer::HEADER_PHPDOC,
            ],
        ];

        yield ["<?php\nphpinfo();\n?>\n<?", null, ['header' => '']];

        yield [" <?php\nphpinfo();\n", null, ['header' => '']];

        yield ["<?php\nphpinfo();\n?><hr/>", null, ['header' => '']];

        yield ["  <?php\n", null, ['header' => '']];

        yield ['<?= 1?>', null, ['header' => '']];

        yield ["<?= 1?><?php\n", null, ['header' => '']];

        yield ["<?= 1?>\n<?php\n", null, ['header' => '']];

        yield ["<?php\n// comment 1\n?><?php\n// comment 2\n", null, ['header' => '']];

        yield [
            "<?php\r\ndeclare(strict_types=1);\r\n/**\r\n * whitemess\r\n */\r\n\r\nnamespace A\\B;\r\n\r\necho 1;",
            "<?php\r\ndeclare(strict_types=1);\r\n\r\nnamespace A\\B;\r\n\r\necho 1;",
            [
                'header' => 'whitemess',
                'location' => 'after_declare_strict',
                'separate' => 'bottom',
                'comment_type' => HeaderCommentFixer::HEADER_PHPDOC,
            ],
            new WhitespacesFixerConfig("\t", "\r\n"),
        ];

        yield [
            "<?php\n\n/*\n * Foo\n */\n\necho 1;",
            "<?php\necho 1;",
            ['header' => 'Foo'],
        ];

        yield [
            "<?php\r\n\r\n/*\r\n * Foo\r\n */\r\n\r\necho 1;",
            "<?php\r\necho 1;",
            ['header' => 'Foo'],
            new WhitespacesFixerConfig('    ', "\r\n"),
        ];

        yield [
            "<?php\r\n\r\n/*\r\n * Bar\r\n */\r\n\r\necho 1;",
            "<?php\r\necho 1;",
            ['header' => 'Bar'],
            new WhitespacesFixerConfig('    ', "\r\n"),
        ];

        yield [
            "<?php\n\n/*\n * Bar\n */\n\necho 1;",
            "<?php\necho 1;",
            ['header' => 'Bar'],
            new WhitespacesFixerConfig('    ', "\n"),
        ];
    }

    /**
     * @param _AutogeneratedInputConfiguration $configuration
     *
     * @dataProvider provideFix81Cases
     *
     * @requires PHP 8.1
     */
    public function testFix81(string $expected, ?string $input, array $configuration): void
    {
        $this->testFix($expected, $input, $configuration);
    }

    /**
     * @return iterable<int, array{string, null|string, _AutogeneratedInputConfiguration}>
     */
    public static function provideFix81Cases(): iterable
    {
        yield [
            '<?php

/*
 * tmp
 */

/**
 * Foo class doc.
 */
enum Foo {}',
            '<?php

/**
 * Foo class doc.
 */
enum Foo {}',
            ['header' => 'tmp'],
        ];
    }

    /**
     * @param _AutogeneratedInputConfiguration                 $configuration
     * @param class-string<InvalidFixerConfigurationException> $exception
     *
     * @dataProvider provideInvalidConfigurationCases
     */
    public function testInvalidConfiguration(
        ?array $configuration,
        string $exceptionMessage,
        string $exception = InvalidFixerConfigurationException::class
    ): void {
        $this->expectException($exception);
        $this->expectExceptionMessageMatches("#^\\[header_comment\\] {$exceptionMessage}$#");

        if (null !== $configuration) {
            $this->fixer->configure($configuration);
        } else {
            $this->doTest('<?php echo 1;');
        }
    }

    /**
     * @return iterable<int, array{null|array<array-key, mixed>, string}>
     */
    public static function provideInvalidConfigurationCases(): iterable
    {
        yield [
            null,
            'Configuration is required.',
            RequiredFixerConfigurationException::class,
        ];

        yield [[], 'Missing required configuration: The required option "header" is missing.'];

        yield [
            ['header' => 1],
            'Invalid configuration: The option "header" with value 1 is expected to be of type "string", but is of type "(int|integer)"\.',
        ];

        yield [
            [
                'header' => '',
                'comment_type' => 'foo',
            ],
            'Invalid configuration: The option "comment_type" with value "foo" is invalid\. Accepted values are: "PHPDoc", "comment"\.',
        ];

        yield [
            [
                'header' => '',
                'comment_type' => new \stdClass(),
            ],
            'Invalid configuration: The option "comment_type" with value stdClass is invalid\. Accepted values are: "PHPDoc", "comment"\.',
        ];

        yield [
            [
                'header' => '',
                'location' => new \stdClass(),
            ],
            'Invalid configuration: The option "location" with value stdClass is invalid\. Accepted values are: "after_open", "after_declare_strict"\.',
        ];

        yield [
            [
                'header' => '',
                'separate' => new \stdClass(),
            ],
            'Invalid configuration: The option "separate" with value stdClass is invalid\. Accepted values are: "both", "top", "bottom", "none"\.',
        ];

        yield [
            [
                'header' => 'Foo',
                'validator' => '/\w+++/',
            ],
            'Provided RegEx is not valid.',
        ];

        yield [
            [
                'header' => '/** test */',
                'comment_type' => HeaderCommentFixer::HEADER_PHPDOC,
            ],
            'Cannot use \'\*/\' in header\.$',
        ];
    }
}
