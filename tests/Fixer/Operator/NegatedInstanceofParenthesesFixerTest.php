<?php

declare(strict_types=1);

/*
 * This file is part of PHP CS Fixer.
 *
 * (c) Fabien Potencier <fabien@symfony.com>
 *     Dariusz Rumiński <dariusz.ruminski@gmail.com>
 *
 * This source file is subject to the MIT license that is bundled
 * with this source code in the file LICENSE.
 */

namespace PhpCsFixer\Tests\Fixer\Operator;

use PhpCsFixer\Tests\Test\AbstractFixerTestCase;

/**
 * @internal
 *
 * @covers \PhpCsFixer\Fixer\Operator\NegatedInstanceofParenthesesFixer
 *
 * @extends AbstractFixerTestCase<\PhpCsFixer\Fixer\Operator\NegatedInstanceofParenthesesFixer>
 *
 * @author Jérôme Gamez <jerome@gamez.name>
 *
 * @phpstan-import-type _AutogeneratedInputConfiguration from \PhpCsFixer\Fixer\Operator\NegatedInstanceofParenthesesFixer
 *
 * @no-named-arguments Parameter names are not covered by the backward compatibility promise.
 */
final class NegatedInstanceofParenthesesFixerTest extends AbstractFixerTestCase
{
    /**
     * @param _AutogeneratedInputConfiguration $configuration
     *
     * @dataProvider provideFixCases
     */
    public function testFix(string $expected, ?string $input = null, array $configuration = []): void
    {
        $this->fixer->configure($configuration);
        $this->doTest($expected, $input);
    }

    /**
     * @return iterable<string, array{0: string, 1?: ?string, 2?: _AutogeneratedInputConfiguration}>
     */
    public static function provideFixCases(): iterable
    {
        yield 'default' => [
            '<?php !$x instanceof Foo;',
            '<?php !($x instanceof Foo);',
        ];

        yield 'wrap_simple' => [
            '<?php !($x instanceof Foo);',
            '<?php !$x instanceof Foo;',
            ['use_parentheses' => true],
        ];

        yield 'wrap_with_fqn' => [
            '<?php !($x instanceof \A\B\C);',
            '<?php !$x instanceof \A\B\C;',
            ['use_parentheses' => true],
        ];

        yield 'wrap_with_namespace_relative' => [
            '<?php !($x instanceof namespace\Foo);',
            '<?php !$x instanceof namespace\Foo;',
            ['use_parentheses' => true],
        ];

        yield 'wrap_with_self' => [
            '<?php !($x instanceof self);',
            '<?php !$x instanceof self;',
            ['use_parentheses' => true],
        ];

        yield 'wrap_with_static' => [
            '<?php !($x instanceof static);',
            '<?php !$x instanceof static;',
            ['use_parentheses' => true],
        ];

        yield 'wrap_with_parent' => [
            '<?php !($x instanceof parent);',
            '<?php !$x instanceof parent;',
            ['use_parentheses' => true],
        ];

        yield 'wrap_already_wrapped' => [
            '<?php !($x instanceof Foo);',
            null,
            ['use_parentheses' => true],
        ];

        yield 'wrap_not_negated' => [
            '<?php $x instanceof Foo;',
            null,
            ['use_parentheses' => false],
        ];

        yield 'wrap_multiple_negated_expressions' => [
            '<?php !($x instanceof Foo) && !($y instanceof Bar);',
            '<?php !$x instanceof Foo && !$y instanceof Bar;',
            ['use_parentheses' => true],
        ];

        yield 'wrap_mixed_negated_and_non_negated' => [
            '<?php !($x instanceof Foo) && $y instanceof Bar;',
            '<?php !$x instanceof Foo && $y instanceof Bar;',
            ['use_parentheses' => true],
        ];

        yield 'wrap_mixed_wrapped_and_unwrapped' => [
            '<?php !(!($x instanceof Foo) && !($y instanceof Bar));',
            '<?php !(!$x instanceof Foo && !($y instanceof Bar));',
            ['use_parentheses' => true],
        ];

        yield 'unwrap_simple' => [
            '<?php !$x instanceof Foo;',
            '<?php !($x instanceof Foo);',
            ['use_parentheses' => false],
        ];

        yield 'unwrap_with_fqn' => [
            '<?php !$x instanceof \A\B\C;',
            '<?php !($x instanceof \A\B\C);',
            ['use_parentheses' => false],
        ];

        yield 'unwrap_with_self' => [
            '<?php !$x instanceof self;',
            '<?php !($x instanceof self);',
            ['use_parentheses' => false],
        ];

        yield 'unwrap_with_static' => [
            '<?php !$x instanceof static;',
            '<?php !($x instanceof static);',
            ['use_parentheses' => false],
        ];

        yield 'unwrap_with_parent' => [
            '<?php !$x instanceof parent;',
            '<?php !($x instanceof parent);',
            ['use_parentheses' => false],
        ];

        yield 'unwrap_with_namespace_relative' => [
            '<?php !$x instanceof namespace\Foo;',
            '<?php !($x instanceof namespace\Foo);',
            ['use_parentheses' => false],
        ];

        yield 'unwrap_multiple_expressions' => [
            '<?php !$x instanceof Foo && !$y instanceof Bar;',
            '<?php !($x instanceof Foo) && !($y instanceof Bar);',
            ['use_parentheses' => false],
        ];

        yield 'unwrap_mixed_negated_and_non_negated' => [
            '<?php !$x instanceof Foo && $y instanceof Bar;',
            '<?php !($x instanceof Foo) && $y instanceof Bar;',
            ['use_parentheses' => false],
        ];

        yield 'unwrap_already_unwrapped' => [
            '<?php !$x instanceof Foo;',
            null,
            ['use_parentheses' => false],
        ];

        // Intentionally not handled
        yield 'do_not_fix_array_access' => [
            '<?php !$array[$key] instanceof Foo;',
        ];

        yield 'do_not_fix_property_access' => [
            '<?php !$obj->prop instanceof Foo;',
        ];

        yield 'do_not_fix_method_call' => [
            '<?php !$obj->method()->prop instanceof Foo;',
        ];

        yield 'do_not_fix_function_call' => [
            '<?php !foo() instanceof Foo;',
        ];
    }
}
