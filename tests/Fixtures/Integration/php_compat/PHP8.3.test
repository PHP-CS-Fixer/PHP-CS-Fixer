--TEST--
PHP 8.3 test.

@TODO Fix whitespace inside dynamic const fetch, e.g. `Foo::{  $bar  }`
@TODO Fix whitespace between const type and const name, e.g. `public const string       TEST = 'Test1';`
--RULESET--
{
    "@PhpCsFixer": true,
    "@PHP8x3Migration": true
}
--REQUIREMENTS--
{"php": 80300}
--EXPECT--
<?php

// https://wiki.php.net/rfc/arbitrary_static_variable_initializers
function foo(int $j)
{
    static $i = bar($j * $j);
}

// https://wiki.php.net/rfc/dynamic_class_constant_fetch
class Foo
{
    public const BAR = 'bar';
}
$bar = 'BAR';
function bar(): string
{
    return 'BAR';
}
$baz = ['bar' => ['bar' => 'BAR']];

echo Foo::{$bar};
echo Foo::{bar()};
echo Foo::{$baz['bar']['bar']};

// https://wiki.php.net/rfc/typed_class_constants
enum E
{
    public const string TEST = 'Test1';
}

trait T
{
    public const string TEST = E::TEST;
}

interface I
{
    public const string TEST = E::TEST;
}

class Foo implements I
{
    use T;

    public const string TEST = E::TEST;
}

class Bar extends Foo
{
    public const string TEST = 'Test2';
}

// https://www.php.net/manual/en/migration83.new-features.php#migration83.new-features.core.readonly-modifier-improvements
$a = new readonly class {};

// https://wiki.php.net/rfc/typed_class_constants with no_unused_imports
use Vendor\TypeA;
use Vendor\TypeB;
use Vendor\TypeC;
use Vendor\TypeD;
use Vendor\TypeE;
use Vendor\TypeF;

class TypedConst
{
    public const TypeA REGULAR = TheParentType::Foo;
    public const ?TypeB NULLABLE = TheParentType::Foo;
    public const TypeC|TypeD UNION = TheParentType::Foo;
    public const TypeE&TypeF INTERSECTION = TheParentType::Foo;
}

--INPUT--
<?php

// https://wiki.php.net/rfc/arbitrary_static_variable_initializers
function foo(    int     $j     ) {
    static       $i  =  bar (  $j     *     $j ) ;
}

// https://wiki.php.net/rfc/dynamic_class_constant_fetch
class Foo {
    const BAR = 'bar';
}
$bar = 'BAR';
function bar(): string { return 'BAR'; }
$baz = ['bar' => ['bar' => 'BAR']];

echo Foo    ::    {$bar};
echo Foo    ::    {bar  (   )};
echo Foo    ::    {$baz    [   'bar'    ]    [    'bar'    ]};

// https://wiki.php.net/rfc/typed_class_constants
enum E {
    const    StRiNg TEST = "Test1";
}

trait T {
    const        STRING TEST = E::TEST;
}

interface I {
    const                      StrinG TEST = E::TEST;
}

class Foo implements I {
    use T;

    const   strIng TEST = E::TEST;
}
 
class Bar extends Foo {
    const
           string TEST = "Test2";
}

// https://www.php.net/manual/en/migration83.new-features.php#migration83.new-features.core.readonly-modifier-improvements
$a   =    New     ReadOnly     CLASS
{
};

// https://wiki.php.net/rfc/typed_class_constants with no_unused_imports
use Vendor\TypeA;
use Vendor\TypeB;
use Vendor\TypeC;
use Vendor\TypeD;
use Vendor\TypeE;
use Vendor\TypeF;
use Vendor\TypeUnused;

class TypedConst {
    public const TypeA REGULAR = TheParentType::Foo;
    public const ?TypeB NULLABLE = TheParentType::Foo;
    public const TypeC|TypeD UNION = TheParentType::Foo;
    public const TypeE&TypeF INTERSECTION = TheParentType::Foo;
}
